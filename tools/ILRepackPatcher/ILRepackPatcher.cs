//
// Author:
//   Aaron Bockover <abock@microsoft.com>
//
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

using System;
using System.IO;
using System.Linq;

using Mono.Cecil;
using Mono.Cecil.Cil;

/// <summary>
/// ILRepack uses an old version of Mono.Cecil that does not work well with
/// assemblies generated by the .NET Core toolchain. TL;DR the .NET Core toolchain
/// writes machine/arch values to the PE header that the Cecil in ILRepack does
/// not know about:
/// https://github.com/dotnet/coreclr/blob/6f7aa7967c607b8c667518314ab937c0d7547025/src/inc/pedecoder.h#L94-L107
/// https://github.com/jbevain/cecil/issues/337
/// </summary>
static class ILRepackPatcher
{
    static void Main (string [] args)
    {
        var file = args [0];
        using (var module = ModuleDefinition.ReadModule (file)) {
            Console.WriteLine ("Patching assembly {0}", file);

            PatchModuleKind (module);
            PatchImageReaderReadArchitecture (module);
            PatchImageWriterWritePEFileHeader (module);
            PatchILRepackRepack (module);

            module.Write (file + ".tmp");
        }

        File.Delete (file);
        File.Move (file + ".tmp", file);
    }

    static void PatchModuleKind (ModuleDefinition module)
    {
        var targetArchitecture = module.GetType ("Mono.Cecil.TargetArchitecture");
        if (targetArchitecture == null || !targetArchitecture.IsEnum || !targetArchitecture.HasFields)
            return;

        foreach (var field in targetArchitecture.Fields) {
            switch (field.Name) {
            case "I386":
                field.Constant = (ushort)0x014c;
                break;
            case "AMD64":
                field.Constant = (ushort)0x8664;
                break;
            case "IA64":
                field.Constant = (ushort)0x0200;
                break;
            case "ARM":
                field.Constant = (ushort)0x01c0;
                break;
            case "ARMv7":
                field.Constant = (ushort)0x01c4;
                break;
            case "ARM64":
                field.Constant = (ushort)0xaa64;
                break;
            }
        }
    }

    static void PatchImageReaderReadArchitecture (ModuleDefinition module)
    {
        // https://github.com/jbevain/cecil/commit/bb40c2108ecf303691d0536c4f9d3b9035790c5c
        var method = module
            .GetType ("Mono.Cecil.PE.ImageReader")
            ?.Methods
            ?.SingleOrDefault (m => m.Name == "ReadArchitecture");

        if (method == null)
            return;

        Console.WriteLine ($"  Patching {method}...");

        var readUInt16 = method.Body.Instructions
            .FirstOrDefault (ins => ins.OpCode == OpCodes.Callvirt &&
                ins.Operand is MethodReference methodReference &&
                methodReference.Name == "ReadUInt16")
            ?.Operand as MethodReference;

        method.Body.Instructions.Clear ();
        var il = method.Body.GetILProcessor ();
        il.Emit (OpCodes.Ldarg_0);
        il.Emit (OpCodes.Callvirt, readUInt16);
        il.Emit (OpCodes.Ret);

        foreach (var i in method.Body.Instructions)
            Console.WriteLine ("    {0}", i);
    }

    static void PatchImageWriterWritePEFileHeader (ModuleDefinition module)
    {
        // https://github.com/jbevain/cecil/commit/3050a6174a1bf9a86618808ad23aca4e19f22553
        var imageWriter = module.GetType ("Mono.Cecil.PE.ImageWriter");
        var method = imageWriter
            ?.Methods
            ?.SingleOrDefault (m => m.Name == "GetMachine");

        if (method == null)
            return;

        Console.WriteLine ($"  Patching {method}...");

        var moduleField = imageWriter.Fields.SingleOrDefault (field => field.Name == "module");
        var moduleTypeDefinition = module.GetType ("Mono.Cecil.ModuleDefinition");
        var architectureProperty = moduleTypeDefinition.Properties.FirstOrDefault (
            property => property.Name == "Architecture");

        method.Body.Instructions.Clear ();
        var il = method.Body.GetILProcessor ();
        il.Emit (OpCodes.Ldarg_0);
        il.Emit (OpCodes.Ldfld, moduleField);
        il.Emit (OpCodes.Callvirt, architectureProperty.GetMethod);
        il.Emit (OpCodes.Ret);

        foreach (var i in method.Body.Instructions)
            Console.WriteLine ("    {0}", i);
    }

    static void PatchILRepackRepack (ModuleDefinition module)
    {
        // ILRepack calls into Mono.Unix which in turn will P/Invoke into
        // MonoPosixHelper. This doesn't exist on .NET Core. Patch out the
        // syscalls that are used to copy attributes. Not a big deal.
        var method = module
            .GetType ("ILRepacking.ILRepack")
            ?.Methods
            ?.SingleOrDefault (m => m.Name == "Repack");

        if (method == null)
            return;

        Console.WriteLine ($"  Patching {method}...");

        var syscalls = method.Body.Instructions
            .Where (i => i.Operand is MethodReference methodReference &&
                methodReference.DeclaringType.FullName == "Mono.Unix.Native.Syscall")
            .ToList ();

        var il = method.Body.GetILProcessor ();

        foreach (var syscall in syscalls) {
            switch (((MethodReference)syscall.Operand).Name) {
            case "stat":
            case "chmod" when syscall.Next.OpCode == OpCodes.Pop:
                Console.WriteLine ("    {0} -> pop", syscall);
                // these each take two arguments and return a value; there is a pop
                // already in the IL, so we just need to replace the call with a
                // single pop.
                il.Replace (syscall, Instruction.Create (OpCodes.Pop));
                break;
            }
        }
    }
}